package org.glob3.mobile.generated;
//
//  BasicShadersGL2.hpp
//  G3MiOSSDK
//
//  Created by Jose Miguel SN on 15/11/13.
//
//



public class BasicShadersGL2 extends GPUProgramFactory
{

  public BasicShadersGL2()
  {
    String emptyString = "";

    GPUProgramSources sourcesBillboard = new GPUProgramSources("Billboard", emptyString + "attribute vec2 aTextureCoord;\n" + "uniform mat4 uModelview;\n" + "uniform vec4 uBillboardPosition;\n" + "uniform vec2 uBillboardAnchor; //Anchor in UV (texture-like) coordinates\n" + "uniform vec2 uTextureExtent;\n" + "uniform vec2 uViewPortExtent;\n" + "varying vec2 TextureCoordOut;\n" + "void main() {\n" + "gl_Position = uModelview * uBillboardPosition;\n" + "float fx = 2.0 * uTextureExtent.x / uViewPortExtent.x * gl_Position.w;\n" + "float fy = 2.0 * uTextureExtent.y / uViewPortExtent.y * gl_Position.w;\n" + "gl_Position.x += ((aTextureCoord.x - 0.5) - (uBillboardAnchor.x - 0.5)) * fx;\n" + "gl_Position.y -= ((aTextureCoord.y - 0.5) - (uBillboardAnchor.y - 0.5)) * fy;\n" + "TextureCoordOut = aTextureCoord;\n" + "}\n", emptyString + "varying mediump vec2 TextureCoordOut;\n" + "uniform sampler2D Sampler;\n" + "void main() {\n" + "gl_FragColor = texture2D(Sampler, TextureCoordOut);\n" + "}\n");
    this.add(sourcesBillboard);

    GPUProgramSources sourcesBillboard_TransformedTexCoor = new GPUProgramSources("Billboard_TransformedTexCoor", emptyString + "attribute vec2 aTextureCoord;\n" + "uniform mat4 uModelview;\n" + "uniform vec4 uBillboardPosition;\n" + "uniform vec2 uBillboardAnchor; //Anchor in UV (texture-like) coordinates\n" + "uniform vec2 uTextureExtent;\n" + "uniform vec2 uViewPortExtent;\n" + "uniform mediump vec2 uTranslationTexCoord;\n" + "uniform mediump vec2 uScaleTexCoord;\n" + "varying vec2 TextureCoordOut;\n" + "void main() {\n" + "gl_Position = uModelview * uBillboardPosition;\n" + "float fx = 2.0 * uTextureExtent.x / uViewPortExtent.x * gl_Position.w;\n" + "float fy = 2.0 * uTextureExtent.y / uViewPortExtent.y * gl_Position.w;\n" + "gl_Position.x += ((aTextureCoord.x - 0.5) - (uBillboardAnchor.x - 0.5)) * fx;\n" + "gl_Position.y -= ((aTextureCoord.y - 0.5) - (uBillboardAnchor.y - 0.5)) * fy;\n" + "TextureCoordOut = (aTextureCoord * uScaleTexCoord) + uTranslationTexCoord;\n" + "}\n", emptyString + "varying mediump vec2 TextureCoordOut;\n" + "uniform sampler2D Sampler;\n" + "void main() {\n" + "gl_FragColor = texture2D(Sampler, TextureCoordOut);\n" + "}\n");
    this.add(sourcesBillboard_TransformedTexCoor);

    GPUProgramSources sourcesColorMesh = new GPUProgramSources("ColorMesh", emptyString + "attribute vec4 aPosition;\n" + "attribute vec4 aColor;\n" + "uniform mat4 uModelview;\n" + "uniform float uPointSize;\n" + "varying vec4 VertexColor;\n" + "void main() {\n" + "gl_Position = uModelview * aPosition;\n" + "VertexColor = aColor;\n" + "gl_PointSize = uPointSize;\n" + "}\n", emptyString + "varying mediump vec4 VertexColor;\n" + "void main() {\n" + "gl_FragColor = VertexColor;\n" + "}\n");
    this.add(sourcesColorMesh);

    GPUProgramSources sourcesDefault = new GPUProgramSources("Default", emptyString + "attribute vec4 aPosition;\n" + "attribute vec2 aTextureCoord;\n" + "attribute vec4 aColor;\n" + "uniform mediump vec2 uTranslationTexCoord;\n" + "uniform mediump vec2 uScaleTexCoord;\n" + "uniform mat4 uModelview;\n" + "uniform float uPointSize;\n" + "varying vec4 VertexColor;\n" + "varying vec2 TextureCoordOut;\n" + "void main() {\n" + "gl_Position = uModelview * aPosition;\n" + "TextureCoordOut = (aTextureCoord * uScaleTexCoord) + uTranslationTexCoord;\n" + "VertexColor = aColor;\n" + "gl_PointSize = uPointSize;\n" + "}\n", emptyString + "varying mediump vec2 TextureCoordOut;\n" + "varying mediump vec4 VertexColor;\n" + "uniform sampler2D Sampler;\n" + "uniform bool EnableTexture;\n" + "uniform lowp vec4 uFlatColor;\n" + "uniform bool EnableColorPerVertex;\n" + "uniform bool EnableFlatColor;\n" + "uniform mediump float FlatColorIntensity;\n" + "uniform mediump float ColorPerVertexIntensity;\n" + "void main() {\n" + "if (EnableTexture) {\n" + "gl_FragColor = texture2D(Sampler, TextureCoordOut);\n" + "if (EnableFlatColor || EnableColorPerVertex) {\n" + "lowp vec4 color;\n" + "if (EnableFlatColor) {\n" + "color = uFlatColor;\n" + "if (EnableColorPerVertex) {\n" + "color = color * VertexColor;\n" + "}\n" + "}\n" + "else {\n" + "color = VertexColor;\n" + "}\n" + "lowp float intensity = (FlatColorIntensity + ColorPerVertexIntensity) / 2.0;\n" + "gl_FragColor = mix(gl_FragColor,\n" + "VertexColor,\n" + "intensity);\n" + "}\n" + "}\n" + "else {\n" + "if (EnableColorPerVertex) {\n" + "gl_FragColor = VertexColor;\n" + "if (EnableFlatColor) {\n" + "gl_FragColor = gl_FragColor * uFlatColor;\n" + "}\n" + "}\n" + "else {\n" + "gl_FragColor = uFlatColor;\n" + "}\n" + "}\n" + "}\n");
    this.add(sourcesDefault);

    GPUProgramSources sourcesFlatColor2DMesh = new GPUProgramSources("FlatColor2DMesh", emptyString + "attribute vec2 aPosition2D;\n" + "uniform float uPointSize;\n" + "uniform vec2 uTranslation2D;\n" + "uniform vec2 uViewPortExtent;\n" + "void main() {\n" + "vec2 pixel = aPosition2D;\n" + "pixel.x -= uViewPortExtent.x / 2.0;\n" + "pixel.y += uViewPortExtent.y / 2.0;\n" + "gl_Position = vec4((pixel.x + uTranslation2D.x) / (uViewPortExtent.x / 2.0),\n" + "(pixel.y - uTranslation2D.y) / (uViewPortExtent.y / 2.0),\n" + "0, 1);\n" + "gl_PointSize = uPointSize;\n" + "}\n", emptyString + "uniform lowp vec4 uFlatColor;\n" + "void main() {\n" + "gl_FragColor = uFlatColor;\n" + "}\n");
    this.add(sourcesFlatColor2DMesh);

    GPUProgramSources sourcesFlatColorMesh = new GPUProgramSources("FlatColorMesh", emptyString + "attribute vec4 aPosition;\n" + "uniform mat4 uModelview;\n" + "uniform float uPointSize;\n" + "void main() {\n" + "gl_Position = uModelview * aPosition;\n" + "gl_PointSize = uPointSize;\n" + "}\n", emptyString + "uniform lowp vec4 uFlatColor;\n" + "void main() {\n" + "gl_FragColor = uFlatColor;\n" + "}\n");
    this.add(sourcesFlatColorMesh);

    GPUProgramSources sourcesFlatColorMesh_DirectionLight = new GPUProgramSources("FlatColorMesh_DirectionLight", emptyString + "attribute vec4 aPosition;\n" + "attribute vec3 aNormal;\n" + "uniform mat4 uModelview;\n" + "uniform mat4 uModel;\n" + "uniform float uPointSize;\n" + "uniform vec3 uAmbientLightColor;\n" + "uniform vec3 uDiffuseLightColor;\n" + "uniform vec3 uDiffuseLightDirection; //We must normalize\n" + "varying vec3 lightColor;\n" + "void main() {\n" + "vec3 normalInModel = normalize( vec3(uModel * vec4(aNormal, 0.0) ));\n" + "vec3 lightDirNormalized = normalize( uDiffuseLightDirection );\n" + "float diffuseLightIntensity = max(dot(normalInModel, lightDirNormalized), 0.0);\n" + "gl_Position = uModelview * aPosition;\n" + "gl_PointSize = uPointSize;\n" + "lightColor = uAmbientLightColor + uDiffuseLightColor * diffuseLightIntensity;\n" + "lightColor.x = min(lightColor.x, 1.0);\n" + "lightColor.y = min(lightColor.y, 1.0);\n" + "lightColor.z = min(lightColor.z, 1.0);\n" + "}\n", emptyString + "#ifdef GL_FRAGMENT_PRECISION_HIGH\n" + "precision highp float;\n" + "#else\n" + "precision mediump float;\n" + "#endif\n" + "uniform lowp vec4 uFlatColor;\n" + "varying vec3 lightColor;\n" + "void main() {\n" + "gl_FragColor.r = uFlatColor.r * lightColor.r;\n" + "gl_FragColor.g = uFlatColor.g * lightColor.r;\n" + "gl_FragColor.b = uFlatColor.b * lightColor.r;\n" + "gl_FragColor.a = uFlatColor.a;\n" + "}\n");
    this.add(sourcesFlatColorMesh_DirectionLight);

    GPUProgramSources sourcesFullTransformedTexCoorMultiTexturedMesh = new GPUProgramSources("FullTransformedTexCoorMultiTexturedMesh", emptyString + "attribute vec4 aPosition;\n" + "attribute vec2 aTextureCoord;\n" + "attribute vec2 aTextureCoord2;\n" + "uniform mat4 uModelview;\n" + "uniform float uPointSize;\n" + "varying vec2 TextureCoordOut;\n" + "varying vec2 TextureCoordOut2;\n" + "uniform mediump vec2 uTranslationTexCoord;\n" + "uniform mediump vec2 uScaleTexCoord;\n" + "uniform float uRotationAngleTexCoord;\n" + "uniform vec2 uRotationCenterTexCoord;\n" + "void main() {\n" + "gl_Position = uModelview * aPosition;\n" + "float s = sin( uRotationAngleTexCoord );\n" + "float c = cos( uRotationAngleTexCoord );\n" + "TextureCoordOut = (aTextureCoord * uScaleTexCoord) + uTranslationTexCoord;\n" + "TextureCoordOut = TextureCoordOut - uRotationCenterTexCoord;\n" + "TextureCoordOut = vec2((TextureCoordOut.x * c) + (TextureCoordOut.y * s),\n" + "(-TextureCoordOut.x * s) + (TextureCoordOut.y * c));\n" + "TextureCoordOut += uRotationCenterTexCoord;\n" + "TextureCoordOut2 = aTextureCoord2;\n" + "gl_PointSize = uPointSize;\n" + "}\n", emptyString + "varying mediump vec2 TextureCoordOut;\n" + "varying mediump vec2 TextureCoordOut2;\n" + "uniform sampler2D Sampler;\n" + "uniform sampler2D Sampler2;\n" + "void main() {\n" + "mediump vec4 tex1 = texture2D(Sampler, TextureCoordOut);\n" + "mediump vec4 tex2 = texture2D(Sampler2, TextureCoordOut2);\n" + "gl_FragColor = tex1 * tex2;\n" + "}\n");
    this.add(sourcesFullTransformedTexCoorMultiTexturedMesh);

    GPUProgramSources sourcesFullTransformedTexCoorTexturedMesh = new GPUProgramSources("FullTransformedTexCoorTexturedMesh", emptyString + "attribute vec4 aPosition;\n" + "attribute vec2 aTextureCoord;\n" + "uniform mediump vec2 uTranslationTexCoord;\n" + "uniform mediump vec2 uScaleTexCoord;\n" + "uniform mat4 uModelview;\n" + "uniform float uPointSize;\n" + "uniform float uRotationAngleTexCoord;\n" + "uniform vec2 uRotationCenterTexCoord;\n" + "varying vec4 VertexColor;\n" + "varying vec2 TextureCoordOut;\n" + "void main() {\n" + "gl_Position = uModelview * aPosition;\n" + "float s = sin( uRotationAngleTexCoord );\n" + "float c = cos( uRotationAngleTexCoord );\n" + "TextureCoordOut = (aTextureCoord * uScaleTexCoord) + uTranslationTexCoord;\n" + "TextureCoordOut = TextureCoordOut - uRotationCenterTexCoord;\n" + "TextureCoordOut = vec2((TextureCoordOut.x * c) + (TextureCoordOut.y * s),\n" + "(-TextureCoordOut.x * s) + (TextureCoordOut.y * c));\n" + "TextureCoordOut += uRotationCenterTexCoord;\n" + "gl_PointSize = uPointSize;\n" + "}\n", emptyString + "varying mediump vec2 TextureCoordOut;\n" + "varying mediump vec4 VertexColor;\n" + "uniform sampler2D Sampler;\n" + "void main() {\n" + "gl_FragColor = texture2D(Sampler, TextureCoordOut);\n" + "}\n");
    this.add(sourcesFullTransformedTexCoorTexturedMesh);

    GPUProgramSources sourcesMultiTexturedMesh = new GPUProgramSources("MultiTexturedMesh", emptyString + "attribute vec4 aPosition;\n" + "attribute vec2 aTextureCoord;\n" + "attribute vec2 aTextureCoord2;\n" + "uniform mat4 uModelview;\n" + "uniform float uPointSize;\n" + "varying vec2 TextureCoordOut;\n" + "varying vec2 TextureCoordOut2;\n" + "void main() {\n" + "gl_Position = uModelview * aPosition;\n" + "TextureCoordOut = aTextureCoord;\n" + "TextureCoordOut2 = aTextureCoord2;\n" + "gl_PointSize = uPointSize;\n" + "}\n", emptyString + "varying mediump vec2 TextureCoordOut;\n" + "varying mediump vec2 TextureCoordOut2;\n" + "uniform sampler2D Sampler;\n" + "uniform sampler2D Sampler2;\n" + "void main() {\n" + "mediump vec4 tex1 = texture2D(Sampler, TextureCoordOut);\n" + "mediump vec4 tex2 = texture2D(Sampler2, TextureCoordOut2);\n" + "gl_FragColor = tex1 * tex2;\n" + "}\n");
    this.add(sourcesMultiTexturedMesh);

    GPUProgramSources sourcesNoColorMesh = new GPUProgramSources("NoColorMesh", emptyString + "attribute vec4 aPosition;\n" + "uniform mat4 uModelview;\n" + "uniform float uPointSize;\n" + "void main() {\n" + "gl_Position = uModelview * aPosition;\n" + "gl_PointSize = uPointSize;\n" + "}\n", emptyString + "void main() {\n" + "gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); //RED\n" + "}\n");
    this.add(sourcesNoColorMesh);

    GPUProgramSources sourcesShader = new GPUProgramSources("Shader", emptyString + "attribute vec4 Position;\n" + "attribute vec2 TextureCoord;\n" + "attribute vec4 Color;\n" + "uniform mediump vec2 TranslationTexCoord;\n" + "uniform mediump vec2 ScaleTexCoord;\n" + "uniform mat4 Projection;\n" + "uniform mat4 Modelview;\n" + "uniform bool BillBoard;\n" + "uniform vec2 TextureExtent;\n" + "uniform vec2 ViewPortExtent;\n" + "uniform float PointSize;\n" + "varying vec4 VertexColor;\n" + "varying vec2 TextureCoordOut;\n" + "void main() {\n" + "gl_Position = Projection * Modelview * Position;\n" + "if (BillBoard) {\n" + "gl_Position.x += ((TextureCoord.x - 0.5) * 2.0 * TextureExtent.x / ViewPortExtent.x) * gl_Position.w;\n" + "gl_Position.y -= ((TextureCoord.y - 0.5) * 2.0 * TextureExtent.y / ViewPortExtent.y) * gl_Position.w;\n" + "}\n" + "TextureCoordOut = (TextureCoord * ScaleTexCoord) + TranslationTexCoord;\n" + "VertexColor = Color;\n" + "gl_PointSize = PointSize;\n" + "}\n", emptyString + "varying mediump vec2 TextureCoordOut;\n" + "varying mediump vec4 VertexColor;\n" + "uniform sampler2D Sampler;\n" + "uniform bool EnableTexture;\n" + "uniform lowp vec4 FlatColor;\n" + "uniform bool EnableColorPerVertex;\n" + "uniform bool EnableFlatColor;\n" + "uniform mediump float FlatColorIntensity;\n" + "uniform mediump float ColorPerVertexIntensity;\n" + "void main() {\n" + "if (EnableTexture) {\n" + "gl_FragColor = texture2D(Sampler, TextureCoordOut);\n" + "if (EnableFlatColor || EnableColorPerVertex) {\n" + "lowp vec4 color;\n" + "if (EnableFlatColor) {\n" + "color = FlatColor;\n" + "if (EnableColorPerVertex) {\n" + "color = color * VertexColor;\n" + "}\n" + "}\n" + "else {\n" + "color = VertexColor;\n" + "}\n" + "lowp float intensity = (FlatColorIntensity + ColorPerVertexIntensity) / 2.0;\n" + "gl_FragColor = mix(gl_FragColor,\n" + "VertexColor,\n" + "intensity);\n" + "}\n" + "}\n" + "else {\n" + "if (EnableColorPerVertex) {\n" + "gl_FragColor = VertexColor;\n" + "if (EnableFlatColor) {\n" + "gl_FragColor = gl_FragColor * FlatColor;\n" + "}\n" + "}\n" + "else {\n" + "gl_FragColor = FlatColor;\n" + "}\n" + "}\n" + "}\n");
    this.add(sourcesShader);
    
    String atmVS = "attribute vec4 aPosition; //Position of ZNear Frame corners in world-space\r\nuniform mat4 uModelview; //Model + Projection\r\n\r\nuniform float uPointSize;\r\n\r\nuniform highp vec3 uCameraPosition;\r\nvarying highp vec3 rayDir;\r\n\r\nvoid main() {\r\n  gl_Position = uModelview * aPosition;\r\n  gl_Position.z = 0.0;\r\n\r\n  gl_PointSize = uPointSize;\r\n  highp vec3 planePos = aPosition.xyz;\r\n\r\n  //Ray [O + tD = X]\r\n  rayDir = planePos - uCameraPosition;\r\n}\r\n";
    String atmFS = "//\r\n//  Default.vsh\r\n//\r\n//  Created by Jos\u00E9 Miguel Santana N\u00FA\u00F1ez\r\n//\r\n\r\nprecision highp float;\r\n\r\nuniform highp vec3 uCameraPosition;\r\nvarying highp vec3 rayDir;\r\n\r\n//uniform highp vec3 currentSunDir;\r\nhighp vec3 currentSunDir = vec3(1.0, 0.0, 0.0);\r\n\r\n//Earth, atmosphere and sun parameters\r\nconst highp float earthRadius = 6.36744e6;\r\nconst highp float atmUndergroundOffset = 100e3;\r\nconst highp float atmosphereScale = 3.0; //Atm. scale\r\nconst highp float stratoHeight = 50e3 * atmosphereScale;\r\nconst highp float atmRadius = earthRadius + stratoHeight;\r\nconst highp float earth2AtmRatio = earthRadius / atmRadius;\r\n\r\n\r\n//Color space conversion\r\nconst highp mat3 CIE2RGB = mat3(3.2405,   -0.9693,    0.0556,\r\n                                -1.5371,    1.8760,   -0.2040,\r\n                                -0.4985,    0.0416,    1.0572);\r\n\r\nconst highp mat3 RGB2CIE = mat3(0.4125,    0.2127,    0.0193,\r\n                                0.3576,    0.7152,    0.1192,\r\n                                0.1804,    0.0722,    0.9503);\r\n\r\nconst float NaN = sqrt(-1.0);\r\n\r\nhighp mat4 rotationMatrix(highp vec3 axis, highp float angle)\r\n{\r\n  axis = normalize(axis);\r\n  highp float s = sin(angle);\r\n  highp float c = cos(angle);\r\n  highp float oc = 1.0 - c;\r\n  \r\n  return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\r\n              oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\r\n              oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\r\n              0.0,                                0.0,                                0.0,                                1.0);\r\n}\r\n\r\nhighp vec2 raySphereIntersect(highp vec3 r0, highp vec3 rd, highp vec3 s0, highp float sr) {\r\n  // - r0: ray origin\r\n  // - rd: ray direction\r\n  // - s0: sphere center\r\n  // - sr: sphere radius\r\n  // - Returns distance intersecion with sphere,\r\n  //   or -1.0 if no intersection.\r\n  highp float a = dot(rd, rd);\r\n  highp vec3 s0_r0 = r0 - s0;\r\n  highp float b = 2.0 * dot(rd, s0_r0);\r\n  highp float c = dot(s0_r0, s0_r0) - (sr * sr);\r\n  \r\n  highp float sq = b*b - 4.0*a*c;\r\n  \r\n  if (sq < 0.0) {\r\n    return vec2(-1.0, -1.0);\r\n  }\r\n  \r\n  sq = sqrt(b*b - 4.0*a*c);\r\n  highp float s1 = (-b - sq)/(2.0*a);\r\n  highp float s2 = (-b + sq)/(2.0*a);\r\n\r\n  return vec2(min(s1,s2), max(s1,s2));\r\n}\r\n\r\n\r\nhighp mat3 getChangeOfBasis(in highp vec3 pa, in  highp vec3 pb,\r\n                            out  highp float x0,\r\n                            out  highp float x1,\r\n                            out  highp float y0){\r\n  \r\n  highp float tol = 20000.0;\r\n  \r\n  //if (abs(pa.y - pa.b) > tol && abs(pa.z + pb.z) < tol){\r\n  //\terrorColor.g = 1.0;\r\n  //}\r\n  \r\n  \r\n  highp vec3 d = normalize(pb - pa);\r\n  highp vec3 c = normalize(pa + (dot(-pa,d)*d));\r\n  \r\n  //Change of basis to 2D formula\r\n  highp mat3 m;\r\n  m[0] = d;\r\n  m[1] = c;\r\n  m[2] = cross(c,d);\r\n  \r\n  //m = transpose(m);\r\n  highp mat3 m2;\r\n  m2[0][0] = m[0][0];\r\n  m2[0][1] = m[1][0];\r\n  m2[0][2] = m[2][0];\r\n  \r\n  m2[1][0] = m[0][1];\r\n  m2[1][1] = m[1][1];\r\n  m2[1][2] = m[2][1];\r\n  \r\n  m2[2][0] = m[0][2];\r\n  m2[2][1] = m[1][2];\r\n  m2[2][2] = m[2][2];\r\n  m = m2;\r\n\r\n  highp vec3 mpa = m * pa;\r\n  highp vec3 mpb = m * pb;\r\n  \r\n  if (abs(mpa.z) > tol || abs(mpa.y - mpb.y) > tol){ //Checking\r\n    x0 = x1 = y0 = 0.0;\r\n    //errorColor = vec4(1.0, 0.0, 0.0, 1.0);\r\n    return m; //Error\r\n  }\r\n  \r\n  x0 = min(mpa.x, mpb.x);\r\n  x1 = max(mpa.x, mpb.x);\r\n  y0 = abs(mpa.y);\r\n  \r\n  if (x0 > 0.0){ //All rays should start from negative X\r\n    float aux = x0;\r\n    x0 = -x1;\r\n    x1 = -aux;\r\n  }\r\n  \r\n  //if (abs(length(pb-pa) - (x1-x0)) > tol){ \terrorColor.r = 1.0;}\r\n  //if (x0 > 0.0 || x1 < x0){ \terrorColor.r = 1.0;}\r\n  \r\n  //if (x0 <0.0 && x1 > 0.0 && abs(x0+x1) > 10.0){\terrorColor.g = 1.0;}\r\n  \r\n  //if (x1 > 0.0) errorColor.b = 1.0;\r\n  \r\n  return m;\r\n}\r\n\r\nfloat sampledXFor5Samples(float x0, float x1, int n){\r\n  \r\n  //if (x0 > 0.0 || x0 > x1) errorColor.g = 1.0;\r\n  \r\n  float d = x1-x0;\r\n  if (x1 <= 0.0){\r\n    \r\n    //errorColor.b = 1.0;\r\n    if (n == 0) return x0;\r\n    if (n == 1) return x0 + d * 0.0321;\r\n    if (n == 2) return x0 + d * 0.1192;\r\n    if (n == 3) return x0 + d * 0.3561;\r\n    if (n == 4) return x1;\r\n  } else{\r\n    \r\n    //Only for external points of view\r\n    //if (abs(x0+x1) > 10000.0) errorColor.g = 1.0; //Centered in 0\r\n    \r\n    if (n == 0) return d * -0.5;\r\n    if (n == 1) return d * -0.1192;\r\n    if (n == 2) return 0.0;\r\n    if (n == 3) return d * 0.1192;\r\n    if (n == 4) return d * 0.5;\r\n  }\r\n  \r\n  return -1.0e10;\r\n}\r\n\r\nhighp mat3 rayTo2D(in highp vec3 pa, in  highp vec3 pb){\r\n  \r\n  highp mat3 m;\r\n  if (abs(pa.z) + distance(pa.y, pb.y) < 1e-7){ //Checking\r\n    m = mat3(1.,0.,0.,\r\n             0.,1.,0.,\r\n             0.,0.,1.);\r\n  } else{\r\n    highp vec3 d = normalize(pb - pa);\r\n    highp vec3 c = normalize(pa + (dot(-pa,d)*d));\r\n    \r\n    //Change of basis to 2D formula\r\n    m[0] = d;\r\n    m[1] = c;\r\n    m[2] = cross(c,d);\r\n    \r\n    //m = transpose(m);\r\n    m = mat3(m[0][0], m[1][0], m[2][0],\r\n             m[0][1], m[1][1], m[2][1],\r\n             m[0][2], m[1][2], m[2][2]);\r\n             \r\n  }\r\n  \r\n  return m;\r\n}\r\n\r\nvec2 earthShadow2D(highp float Y0, highp mat3 m, vec3 sunDir){\r\n  sunDir = normalize(sunDir);\r\n  vec3 p2 = normalize(m * sunDir); //Sun Pos\r\n  \r\n  highp float x2 = p2.x;\r\n  highp float y2 = p2.y;\r\n  highp float z2 = p2.z;\r\n  \r\n  highp float R = earth2AtmRatio;\r\n  \r\n  highp float s = -(pow(x2,2.0)*pow(Y0,2.0)*pow(z2,2.0)) +\r\n  pow(R,2.0)*(pow(y2,2.0) + pow(z2,2.0)) -\r\n  (pow(y2,2.0) + pow(z2,2.0))*pow(Y0*z2,2.0);\r\n  if (s >= 0.0){\r\n    highp float n = x2*Y0*y2;\r\n    highp float d = (pow(y2,2.0) + pow(z2,2.0));\r\n    s = sqrt(s);\r\n    highp float s1 = (n - s)/ d;\r\n    highp float s2 = (n + s)/ d;\r\n    \r\n    //If the entry point is in the same direction than source\r\n    if (distance(vec2(s1,Y0), p2.xy) <  distance(vec2(s1,Y0), -p2.xy)){\r\n      return vec2(s1,s2);\r\n    }\r\n  }\r\n  \r\n  return vec2(NaN, NaN);\r\n}\r\n\r\n//Output: [atm1, atm2, 0, 0] || [atm1, earth1, 0, 0] ||\r\n// [atm1, shadow1, 0, 0] || [atm1, shadow1, shadow2, atm2] ||\r\n// [0,0,0,0]\r\nhighp vec4 getRay2DEnds(vec2 p1, vec2 p2,\r\n                  mat3 m, vec3 sunDir,\r\n                  out bool atm,\r\n                  out bool earth,\r\n                  out bool shadow){\r\n  \r\n  //Intersection atm.\r\n  highp float atm1 = -sqrt(1.0 - p1.y*p1.y);\r\n  highp float atm2 = -atm1;\r\n  atm1 = clamp(atm1, p1.x, p2.x);\r\n  atm2 = clamp(atm2, p1.x, p2.x);\r\n  atm = (atm1 != atm2);\r\n  \r\n  //Intersection earth\r\n  highp float earth1 = -sqrt(earth2AtmRatio*earth2AtmRatio - p1.y*p1.y);\r\n  highp float earth2 = -earth1;\r\n  earth1 = clamp(earth1, p1.x, p2.x);\r\n  earth2 = clamp(earth2, p1.x, p2.x);\r\n  earth = (earth1 != earth2);\r\n  \r\n  //Intersection with earth shadow\r\n  highp vec2 shadows = earthShadow2D(p1.y, m, sunDir);\r\n  highp float rayEnd = earth? earth1 : atm2;\r\n  highp float shadow1 = clamp(shadows.x, atm1, rayEnd);\r\n  highp float shadow2 = clamp(shadows.y, atm1, rayEnd);\r\n  \r\n  shadow = (shadows.x == shadows.x) && (shadow1 != shadow2);\r\n  \r\n  //Cases:\r\n  if (!atm){\r\n    return vec4(0.,0.,0.,0.);\r\n  }\r\n  \r\n  if (!earth && !shadow){\r\n    return vec4(atm1, atm2, 0., 0.);\r\n  }\r\n  \r\n  if (earth && !shadow){\r\n    return vec4(atm1, earth1, 0., 0.);\r\n  }\r\n  \r\n  if (earth && shadow){\r\n    return vec4(atm1, shadow1, 0., 0.);\r\n  }\r\n  \r\n  if (!earth && shadow){\r\n    return vec4(atm1, shadow1, shadow2, atm2);\r\n  }\r\n}\r\n\r\n\r\nconst int nSamplesPrimaryRay = 21;\r\nhighp float sampledXFor21Samples(float x0, float x1, int n){\r\n  \r\n  if (x0*x1 < 0.0){\r\n    if (n == 0) return x0 * 1.000000;\r\n    if (n == 1) return x0 * 0.899549;\r\n    if (n == 2) return x0 * 0.799199;\r\n    if (n == 3) return x0 * 0.698949;\r\n    if (n == 4) return x0 * 0.598800;\r\n    if (n == 5) return x0 * 0.498750;\r\n    if (n == 6) return x0 * 0.398800;\r\n    if (n == 7) return x0 * 0.298951;\r\n    if (n == 8) return x0 * 0.199201;\r\n    if (n == 9) return x0 * 0.099551;\r\n    \r\n    if (n == 10) return 0.0;\r\n    if (n == 0) return x1 * 0.099551;\r\n    if (n == 1) return x1 * 0.199201;\r\n    if (n == 2) return x1 * 0.298951;\r\n    if (n == 3) return x1 * 0.398800;\r\n    if (n == 4) return x1 * 0.498750;\r\n    if (n == 5) return x1 * 0.598800;\r\n    if (n == 6) return x1 * 0.698949;\r\n    if (n == 7) return x1 * 0.799199;\r\n    if (n == 8) return x1 * 0.899549;\r\n    if (n == 9) return x1 * 1.000000;\r\n  }\r\n  \r\n  highp float d = x1-x0;\r\n  if (n == 0) return x0 + d * 0.000000;\r\n  if (n == 1) return x0 + d * 0.184651;\r\n  if (n == 2) return x0 + d * 0.335831;\r\n  if (n == 3) return x0 + d * 0.459606;\r\n  if (n == 4) return x0 + d * 0.560945;\r\n  if (n == 5) return x0 + d * 0.643914;\r\n  if (n == 6) return x0 + d * 0.711844;\r\n  if (n == 7) return x0 + d * 0.767460;\r\n  if (n == 8) return x0 + d * 0.812994;\r\n  if (n == 9) return x0 + d * 0.850274;\r\n  if (n == 10) return x0 + d * 0.880797;\r\n  if (n == 11) return x0 + d * 0.905787;\r\n  if (n == 12) return x0 + d * 0.926247;\r\n  if (n == 13) return x0 + d * 0.942998;\r\n  if (n == 14) return x0 + d * 0.956713;\r\n  if (n == 15) return x0 + d * 0.967941;\r\n  if (n == 16) return x0 + d * 0.977135;\r\n  if (n == 17) return x0 + d * 0.984661;\r\n  if (n == 18) return x0 + d * 0.990824;\r\n  if (n == 19) return x0 + d * 0.995869;\r\n  if (n == 20) return x0 + d * 1.000000;\r\n}\r\n\r\n\r\nfloat gFun(highp float a, highp float r){\r\n  \r\n  if (a > 1.6) return 4.2214e-04; //Mean value beyond a = 1.6\r\n  r = (r - earth2AtmRatio) / (1.0 - earth2AtmRatio); //Normalizing [0..1]\r\n  \r\n  highp float x = r;\r\n  highp float y = a;\r\n  highp float x2 = x*x;\r\n  highp float y2 = y*y;\r\n  highp float x3 = x*x*x;\r\n  highp float y3 = y*y*y;\r\n  highp float x4 = x*x*x*x;\r\n  highp float y4 = y*y*y*y;\r\n  highp float x5 = x*x*x*x*x;\r\n  highp float y5 = y*y*y*y*y;\r\n  \r\n  //Polynomial approximation\r\n  highp float g = 1787776115.6965 + -51039518.5128*x + -5614573368.3089*y +\r\n  865443.705*x2 + 128015133.8374*x*y + 7053069042.9223*y2 +\r\n  -10398.8322*x3 + -1624280.2711*x2*y + -120405648.8163*x*y2 +\r\n  -4430036061.6336*y3 + 93.8694*x4 + 12958.7149*x3*y + 1016173.9827*x2*y2 +\r\n  50332603.1065*x*y3 + 1391246665.5755*y4 + -0.64185*x5 + -57.8523*x4*y +\r\n  -4037.6155*x3*y2 + -211914.0726*x2*y3 + -7890102.7191*x*y4 + -174766723.1861*y5;\r\n  \r\n  g = clamp(g, 0.0, 1.0);\r\n  \r\n  return g;\r\n}\r\n\r\nfloat getOpticalDepthFromInfinity(vec2 p){\r\n  \r\n  highp float a = abs(atan(p.y, p.x)); // Atan->[\u2212Pi,Pi]\r\n  highp float r = length(p);\r\n  \r\n  highp float f;\r\n  if (a > 0.0 && a < 1.57){ //0 < Pi/2\r\n    f = 2.0 * gFun(1.5708, abs(p.y)) - gFun(3.1416 - a, r);\r\n    f = clamp(f, 0.0, 2.0);\r\n  } else{\r\n    f = gFun(a, r);\r\n  }\r\n  \r\n  return f;\r\n}\r\n\r\nhighp float getSolarOutScattering(vec3 p, vec3 sunDir){\r\n  //Assuming the sun is very far\r\n  highp vec3 pc = p - normalize(sunDir);\r\n  \r\n  highp mat3 m = rayTo2D(pc, p);\r\n  pc = m * pc;\r\n  p = m * p;\r\n  \r\n  if (pc.x * p.x < 0.0  && pc.y < earth2AtmRatio){ //Earth shadow\r\n    return -1.0; //Infinity\r\n  } else{\r\n    return getOpticalDepthFromInfinity(p.xy);\r\n  }\r\n}\r\n\r\nhighp float getInnerOutScattering(float x0, float x1, float y0){\r\n  highp float i = getOpticalDepthFromInfinity(vec2(x0, y0));\r\n  highp float f = getOpticalDepthFromInfinity(vec2(x1, y0));\r\n  return (f - i);\r\n}\r\n\r\nhighp float getDensityCoefficient(float x, float y){\r\n  highp vec2 p = vec2(x, y);\r\n  highp float h = (length(p) - earth2AtmRatio) / ((atmRadius - earthRadius) / atmRadius);\r\n  highp float d = exp(-h*6.2547); //Density Coefficient\r\n  return d;\r\n}\r\n\r\nhighp float Xs[nSamplesPrimaryRay];\r\nhighp float scatteringFactors[nSamplesPrimaryRay];\r\nhighp float outScatteringFactors[nSamplesPrimaryRay];\r\nvoid calculateScatteringFactorsAndXs(vec3 sunDir,\r\n                                     vec3 sp1,\r\n                                     vec3 sp2,\r\n                                     highp float x0,\r\n                                     highp float x1,\r\n                                     highp float y0){\r\n  \r\n  highp vec3 ray3DDir = normalize(sp2-sp1);\r\n  for (int i = 0; i < nSamplesPrimaryRay; i++){\r\n    \r\n    Xs[i] = sampledXFor21Samples(x0, x1, i);\r\n    \r\n    highp vec3 p = (Xs[i] - x0) * ray3DDir + sp1;\r\n    \r\n    highp float so = getSolarOutScattering(p ,sunDir);\r\n    if (so < 0.0){\r\n      outScatteringFactors[i] = -1.0;\r\n    } else{\r\n      highp float io = getInnerOutScattering(x0, Xs[i], y0);\r\n      outScatteringFactors[i] = (so + io);\r\n    }\r\n    \r\n    scatteringFactors[i] = getDensityCoefficient(Xs[i], y0);\r\n  }\r\n}\r\n\r\nfloat getAtmWavelengthIntensity(highp float gScale4PiKw4){\r\n  \r\n  //return 1.0; //TODO\r\n  \r\n  //Integrating\r\n  highp float intensity = 0.0;\r\n  \r\n  highp float d_1 = scatteringFactors[0] * exp(- gScale4PiKw4 * outScatteringFactors[0]);\r\n  for (int i = 1; i < nSamplesPrimaryRay; i++){\r\n    \r\n    highp float d = 0.0;\r\n    if (outScatteringFactors[i] >= 0.0){\r\n      d = scatteringFactors[i] * exp(- gScale4PiKw4 * outScatteringFactors[i]);\r\n    }\r\n    \r\n    intensity += ((d + d_1)/2.0) * (Xs[i] - Xs[i-1]); //Trapezoidal integration\r\n    \r\n    d_1 = d; //For next iteration\r\n  }\r\n  \r\n  return intensity;\r\n}\r\n\r\n///////////////////////\r\n\r\nvoid main() {\r\n  \r\n  //Initial points at normal mini-scale\r\n  highp vec3 p1 = uCameraPosition/atmRadius;\r\n  highp vec3 p2 = (uCameraPosition + normalize(rayDir)*1e10)/atmRadius;\r\n  highp mat3 m = rayTo2D(p1, p2);\r\n  \r\n  highp vec2 mp1 = (m * p1).xy;\r\n  highp vec2 mp2 = (m * p2).xy;\r\n  if (mp1.x > mp2.x){\r\n    highp vec2 aux = mp1;\r\n    mp1 = mp2;\r\n    mp2 = aux;\r\n    highp vec3 aux3 = p1;\r\n    p1 = p2;\r\n    p2 = aux3;\r\n  }\r\n  \r\n  bool atm;\r\n  bool earth;\r\n  bool shadow;\r\n  highp vec4 ends = getRay2DEnds(mp1, mp2,\r\n                           m, currentSunDir,\r\n                           atm,\r\n                           earth,\r\n                           shadow);\r\n  \r\n  \r\n  //vec4 bgColor = getBackgroundColor(uCameraPosition, rayDir, currentSunDir, fragCoord);\r\n  highp vec3 bgColor = vec3(0.,0.,0.);\r\n  \r\n  if (atm){\r\n    \r\n    //Auto-generated code\r\n    const int nW = 9;\r\n    highp vec3 CIElevels[9];\r\n    CIElevels[0] = vec3(4.568698e-02, 2.536497e-04, 2.536274e-01); //w = 380.00 - 424.44\r\n    CIElevels[1] = vec3(1.904479e-01, 1.411401e-02, 1.000000e+00); //w = 424.44 - 468.89\r\n    CIElevels[2] = vec3(2.882708e-02, 1.250434e-01, 2.311921e-01); //w = 468.89 - 513.33\r\n    CIElevels[3] = vec3(7.525619e-02, 2.688203e-01, 4.168597e-03); //w = 513.33 - 557.78\r\n    CIElevels[4] = vec3(1.968837e-01, 1.856631e-01, 8.178416e-06); //w = 557.78 - 602.22\r\n    CIElevels[5] = vec3(1.115830e-01, 5.053781e-02, 2.669158e-09); //w = 602.22 - 646.67\r\n    CIElevels[6] = vec3(1.355325e-02, 6.385989e-03, 2.110279e-13); //w = 646.67 - 691.11\r\n    CIElevels[7] = vec3(3.337662e-04, 4.290635e-04, 5.467493e-18); //w = 691.11 - 735.56\r\n    CIElevels[8] = vec3(1.571319e-06, 1.715437e-05, 5.889087e-23); //w = 735.56 - 780.00\r\n    \r\n    highp float I0CIEKw4Scale = 3.654184e+00;\r\n    highp float gScale4PiKw4[9];\r\n    gScale4PiKw4[0] = 333.162685;\r\n    gScale4PiKw4[1] = 219.071773;\r\n    gScale4PiKw4[2] = 149.899974;\r\n    gScale4PiKw4[3] = 105.999174;\r\n    gScale4PiKw4[4] = 77.056384;\r\n    gScale4PiKw4[5] = 57.351578;\r\n    gScale4PiKw4[6] = 43.561685;\r\n    gScale4PiKw4[7] = 33.678328;\r\n    gScale4PiKw4[8] = 26.445582;\r\n    //////////////////////////////////////////////\r\n    \r\n    \r\n    highp vec3 atmCIE = vec3(.0,.0,.0);\r\n    highp vec3 ini, end;\r\n    //Main ray\r\n    if (ends.x - ends.y > 1e-2){\r\n      ini = p1 + ((ends.x - mp1.x) / (mp2.x - mp1.x)) * (p2-p1);\r\n      end = p1 + ((ends.y - mp1.x) / (mp2.x - mp1.x)) * (p2-p1);\r\n      \r\n      \r\n      //Precalculating necessary data\r\n      calculateScatteringFactorsAndXs(currentSunDir,\r\n                                      ini, end,\r\n                                      ends.x, ends.y, mp1.y);\r\n      \r\n      for (int i = 0; i < nW; i++){\r\n        \r\n        highp float intensity = getAtmWavelengthIntensity(gScale4PiKw4[i]); //gScale * 4 * Pi * K / w^-4\r\n        \r\n        atmCIE += CIElevels[i] * intensity;\r\n      }\r\n    }\r\n    \r\n    //Secondary ray\r\n    if (ends.w - ends.z > 1e-2){\r\n      //Precalculating necessary data\r\n      ini = p1 + ((ends.z - mp1.x) / (mp2.x - mp1.x)) * (p2-p1);\r\n      end = p1 + ((ends.w - mp1.x) / (mp2.x - mp1.x)) * (p2-p1);\r\n      \r\n      calculateScatteringFactorsAndXs(currentSunDir,\r\n                                      ini, end,\r\n                                      ends.z, ends.w, mp1.y);\r\n      \r\n      for (int i = 0; i < nW; i++){\r\n        \r\n        highp float intensity = getAtmWavelengthIntensity(gScale4PiKw4[i]); //gScale * 4 * Pi * K / w^-4\r\n        \r\n        atmCIE += CIElevels[i] * intensity;\r\n      }\r\n    }\r\n    \r\n    //Scattering directionality\r\n    highp vec3 rayDir = p2 - p1;\r\n    highp float cosAngle = dot(normalize(currentSunDir), normalize(rayDir));\r\n    highp float fr = (3.0/4.0)* (1.0+pow(cosAngle,2.0));\r\n    \r\n    atmCIE *= I0CIEKw4Scale * atmRadius * fr;\r\n    \r\n"+
    "    highp float dimmingFactor = 1.0e10;\r\n    atmCIE *= dimmingFactor;\r\n    \r\n    //Combining both colors and conversting to RGB\r\n    highp vec3 atmColor = CIE2RGB * atmCIE;\r\n    \r\n    gl_FragColor = vec4(atmColor, 1.0);\r\n    \r\n    \r\n  } else{\r\n    gl_FragColor = vec4(1.,1.,0.,1.);\r\n  }\r\n  \r\n  \r\n  \r\n}\r\n";

    GPUProgramSources sourcesSphericalAtmosphere = new GPUProgramSources("SphericalAtmosphere", atmVS, atmFS);
    this.add(sourcesSphericalAtmosphere);

    GPUProgramSources sourcesTextured2DMesh = new GPUProgramSources("Textured2DMesh", emptyString + "attribute vec2 aPosition2D;\n" + "attribute vec2 aTextureCoord;\n" + "uniform float uPointSize;\n" + "varying vec2 TextureCoordOut;\n" + "uniform vec2 uTranslation2D;\n" + "uniform vec2 uViewPortExtent;\n" + "void main() {\n" + "vec2 pixel = aPosition2D;\n" + "pixel.x -= uViewPortExtent.x / 2.0;\n" + "pixel.y += uViewPortExtent.y / 2.0;\n" + "gl_Position = vec4((pixel.x + uTranslation2D.x) / (uViewPortExtent.x / 2.0),\n" + "(pixel.y - uTranslation2D.y) / (uViewPortExtent.y / 2.0),\n" + "0, 1);\n" + "TextureCoordOut = aTextureCoord;\n" + "gl_PointSize = uPointSize;\n" + "}\n", emptyString + "varying mediump vec2 TextureCoordOut;\n" + "uniform sampler2D Sampler;\n" + "void main() {\n" + "gl_FragColor = texture2D(Sampler, TextureCoordOut);\n" + "}\n");
    this.add(sourcesTextured2DMesh);

    GPUProgramSources sourcesTexturedMesh = new GPUProgramSources("TexturedMesh", emptyString + "attribute vec4 aPosition;\n" + "attribute vec2 aTextureCoord;\n" + "uniform mat4 uModelview;\n" + "uniform float uPointSize;\n" + "varying vec2 TextureCoordOut;\n" + "void main() {\n" + "gl_Position = uModelview * aPosition;\n" + "TextureCoordOut = aTextureCoord;\n" + "gl_PointSize = uPointSize;\n" + "}\n", emptyString + "varying mediump vec2 TextureCoordOut;\n" + "uniform sampler2D Sampler;\n" + "void main() {\n" + "gl_FragColor = texture2D(Sampler, TextureCoordOut);\n" + "}\n");
    this.add(sourcesTexturedMesh);

    GPUProgramSources sourcesTexturedMesh_DirectionLight = new GPUProgramSources("TexturedMesh_DirectionLight", emptyString + "attribute vec4 aPosition;\n" + "attribute vec2 aTextureCoord;\n" + "attribute vec3 aNormal;\n" + "uniform mat4 uModelview;\n" + "uniform mat4 uModel;\n" + "uniform float uPointSize;\n" + "varying vec2 TextureCoordOut;\n" + "uniform vec3 uDiffuseLightDirection; //MUST BE NORMALIZED IN SHADER\n" + "varying float diffuseLightIntensity;\n" + "uniform vec3 uAmbientLightColor;\n" + "uniform vec3 uDiffuseLightColor;\n" + "varying vec3 lightColor;\n" + "void main() {\n" + "vec3 normalInModel = normalize( vec3(uModel * vec4(aNormal, 0.0) ));\n" + "vec3 lightDirNormalized = normalize( uDiffuseLightDirection );\n" + "float diffuseLightIntensity = max(dot(normalInModel, lightDirNormalized), 0.0);\n" + "gl_Position = uModelview * aPosition;\n" + "TextureCoordOut = aTextureCoord;\n" + "gl_PointSize = uPointSize;\n" + "lightColor = uAmbientLightColor + uDiffuseLightColor * diffuseLightIntensity;\n" + "lightColor.x = min(lightColor.x, 1.0);\n" + "lightColor.y = min(lightColor.y, 1.0);\n" + "lightColor.z = min(lightColor.z, 1.0);\n" + "}\n", emptyString + "#ifdef GL_FRAGMENT_PRECISION_HIGH\n" + "precision highp float;\n" + "#else\n" + "precision mediump float;\n" + "#endif\n" + "varying mediump vec2 TextureCoordOut;\n" + "uniform sampler2D Sampler;\n" + "varying vec3 lightColor;\n" + "void main() {\n" + "vec4 texColor = texture2D(Sampler, TextureCoordOut);\n" + "gl_FragColor.r = texColor.r * lightColor.r;\n" + "gl_FragColor.g = texColor.g * lightColor.r;\n" + "gl_FragColor.b = texColor.b * lightColor.r;\n" + "gl_FragColor.a = texColor.a;\n" + "}\n");
    this.add(sourcesTexturedMesh_DirectionLight);

    GPUProgramSources sourcesTransformedTexCoorMultiTexturedMesh = new GPUProgramSources("TransformedTexCoorMultiTexturedMesh", emptyString + "attribute vec4 aPosition;\n" + "attribute vec2 aTextureCoord;\n" + "attribute vec2 aTextureCoord2;\n" + "uniform mat4 uModelview;\n" + "uniform float uPointSize;\n" + "varying vec2 TextureCoordOut;\n" + "varying vec2 TextureCoordOut2;\n" + "uniform mediump vec2 uTranslationTexCoord;\n" + "uniform mediump vec2 uScaleTexCoord;\n" + "void main() {\n" + "gl_Position = uModelview * aPosition;\n" + "TextureCoordOut = (aTextureCoord * uScaleTexCoord) + uTranslationTexCoord;\n" + "TextureCoordOut2 = aTextureCoord2;\n" + "gl_PointSize = uPointSize;\n" + "}\n", emptyString + "varying mediump vec2 TextureCoordOut;\n" + "varying mediump vec2 TextureCoordOut2;\n" + "uniform sampler2D Sampler;\n" + "uniform sampler2D Sampler2;\n" + "void main() {\n" + "mediump vec4 tex1 = texture2D(Sampler, TextureCoordOut);\n" + "mediump vec4 tex2 = texture2D(Sampler2, TextureCoordOut2);\n" + "gl_FragColor = tex1 * tex2;\n" + "}\n");
    this.add(sourcesTransformedTexCoorMultiTexturedMesh);

    GPUProgramSources sourcesTransformedTexCoorTexturedMesh = new GPUProgramSources("TransformedTexCoorTexturedMesh", emptyString + "attribute vec4 aPosition;\n" + "attribute vec2 aTextureCoord;\n" + "uniform mediump vec2 uTranslationTexCoord;\n" + "uniform mediump vec2 uScaleTexCoord;\n" + "uniform mat4 uModelview;\n" + "uniform float uPointSize;\n" + "varying vec4 VertexColor;\n" + "varying vec2 TextureCoordOut;\n" + "void main() {\n" + "gl_Position = uModelview * aPosition;\n" + "TextureCoordOut = (aTextureCoord * uScaleTexCoord) + uTranslationTexCoord;\n" + "gl_PointSize = uPointSize;\n" + "}\n", emptyString + "varying mediump vec2 TextureCoordOut;\n" + "varying mediump vec4 VertexColor;\n" + "uniform sampler2D Sampler;\n" + "void main() {\n" + "gl_FragColor = texture2D(Sampler, TextureCoordOut);\n" + "}\n");
    this.add(sourcesTransformedTexCoorTexturedMesh);

    GPUProgramSources sourcesTransformedTexCoorTexturedMesh_DirectionLight = new GPUProgramSources("TransformedTexCoorTexturedMesh_DirectionLight", emptyString + "attribute vec4 aPosition;\n" + "attribute vec2 aTextureCoord;\n" + "attribute vec3 aNormal;\n" + "uniform mat4 uModelview;\n" + "uniform mat4 uModel;\n" + "uniform float uPointSize;\n" + "varying vec2 TextureCoordOut;\n" + "uniform mediump vec2 uTranslationTexCoord;\n" + "uniform mediump vec2 uScaleTexCoord;\n" + "uniform vec3 uDiffuseLightDirection; //MUST BE NORMALIZED\n" + "varying float diffuseLightIntensity;\n" + "uniform vec3 uAmbientLightColor;\n" + "uniform vec3 uDiffuseLightColor;\n" + "varying vec3 lightColor;\n" + "void main() {\n" + "vec3 normalInModel = normalize( vec3(uModel * vec4(aNormal, 0.0) ));\n" + "vec3 lightDirNormalized = normalize( uDiffuseLightDirection );\n" + "float diffuseLightIntensity = max(dot(normalInModel, lightDirNormalized), 0.0);\n" + "gl_Position = uModelview * aPosition;\n" + "TextureCoordOut = (aTextureCoord * uScaleTexCoord) + uTranslationTexCoord;\n" + "gl_PointSize = uPointSize;\n" + "lightColor = uAmbientLightColor + uDiffuseLightColor * diffuseLightIntensity;\n" + "lightColor.x = min(lightColor.x, 1.0);\n" + "lightColor.y = min(lightColor.y, 1.0);\n" + "lightColor.z = min(lightColor.z, 1.0);\n" + "}\n", emptyString + "#ifdef GL_FRAGMENT_PRECISION_HIGH\n" + "precision highp float;\n" + "#else\n" + "precision mediump float;\n" + "#endif\n" + "varying mediump vec2 TextureCoordOut;\n" + "uniform sampler2D Sampler;\n" + "varying vec3 lightColor;\n" + "void main() {\n" + "vec4 texColor = texture2D(Sampler, TextureCoordOut);\n" + "gl_FragColor.r = texColor.r * lightColor.r;\n" + "gl_FragColor.g = texColor.g * lightColor.r;\n" + "gl_FragColor.b = texColor.b * lightColor.r;\n" + "gl_FragColor.a = texColor.a;\n" + "}\n");
    this.add(sourcesTransformedTexCoorTexturedMesh_DirectionLight);

  }

}
